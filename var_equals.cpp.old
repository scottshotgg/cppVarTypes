#include <var.cpp>

using namespace std;

class var {
            void operator=(const int right) {
                if (type == intType) {
                    *(int*)data = right;
                } else {
                    switch(type) {
                        case stringType:
                            var::~var();
                            type = intType;
                            data = new int(right);
                            break;
                        
                        default:
                            printf("wtf %d\n", type);
                    }
                }
            }

            // template <typename T>
            // void operator=(T right) {
            //     cout << right << " type: " << typeid(right).name() << endl;
            //     cout << typeidMap[typeid(right).name()] << endl;

            //     if (type == typeidMap[typeid(right).name()]) {
            //         // data = new T(right);
            //     } else {
            //         // var::~var();
            //         // type = typeidMap[typeid(right).name()];
            //         // data = new T(right);
            //         switch(typeidMap[typeid(right).name()]) {
            //             case intType:
            //                 // data = new int(right);
            //                 *(int*)data = right;
            //                 break;
            //             case stringType:
            //                 *(string*)data = right;
            //             default:
            //                 printf("couldn't");
            //         }
            //     }

            //     // if (type != typeidMap[typeid(right).name()]) {
            //     //     var::~var();
            //     //     type = typeidMap[typeid(right).name()];
            //     // }
            //     // // data = new T(right);

            //     // switch(type) {
            //     //     case intType:
            //     //         data = new int(right);
            //     //     case stringType:
            //     //         data = new string(right);
            //     //     default:
            //     //         printf("couldn't");
            //     // }
            // }

            void operator=(const char* right) {
                // printf("wat this do %d\n", type);
                // printf("wat this do %d\n", *(int*)data);
                // printf("wat this do right %d\n", right);
                // *(int*)data = right;
                if (type == stringType) {
                    *(string*)data = right;
                }
                 else {
                    switch(type) {
                        case intType:
                            var::~var();
                            type = stringType;
                            data = new string(right);
                            break;
                        
                        default:
                            printf("wtf %d\n", type);
                    }
                }

                return;
            }

            // TODO: FIXME: could not get this to work
            // var& operator=(initializer_list<var> propList) {
            //     //printf("im in");

            //     int propListLen = propList.size();
            //     if (propListLen % 2 != 0) {
            //         cout << "ERROR: invalid amount of arguments to object" << endl;
            //         exit(9);
            //     }

            //     map<string, var> object;

            //     cout << object << endl;

            //     // TODO: ok this is kinda fucking hacky but w/e
            //     // var thing[propListLen];
            //     int i = 0;
            //     var lastItem;
            //     for (auto prop : propList) {
            //         cout << prop << endl;

            //         if (i % 2 == 1) {
            //             object[*(string*)lastItem.Value()] = prop;
            //         } else {
            //             lastItem = prop;
            //         }

            //         i++;
            //     }

            //     cout << object << endl;

            //     // for (int i = 0; i < propListLen; i+=2) {
            //     //     // cout << "i " << i << thing[i] << endl;
            //     //     // cout << "i " << i+1 << thing[i+1] << endl;
            //     //     // FIXME: -SUPER- unsafe, need to make sure they are strings
            //     //     object[*(string*)thing[i].Value()] = thing[i+1];
            //     //     cout << object << endl;
            //     // }


            //     data(new map<string, var>(object));
            // }
}